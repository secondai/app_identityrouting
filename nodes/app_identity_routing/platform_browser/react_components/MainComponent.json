{
  "type": "react_component:0.0.1:local:98912hd89",
  "name": "MainComponent",
  "data": {
    "author": "-----BEGIN PUBLIC KEY-----\nMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCcuXovU+RZy85KMqLakYSH1mdV\nWdpEUtgcXUyGyU5hVeTO7BkV/kxeC2upcxOwNnrBOdsvHI3nrrILgt90/hCSHKzx\nhOFLREorGoKtSEHxI7/SnzzlWtV3gT/IP5GVHIyvuJBx3hCti0dH55DZG8iMGZ2y\ncGpV73Dez3hHmeBh6wIDAQAB\n-----END PUBLIC KEY-----",
    "version": "2",
    "key": "3ae95ba5-2d74-4fa4-846d-768b503c398b",
    "code": "(()=>{\n  return new Promise(async (resolve,reject)=>{\n    try {\n  \n      let sleep = function(ms){\n        return new Promise((resolve,reject)=>{\n          universe.setTimeout(resolve,ms);\n        })\n      }\n      \n      const AceEditor = universe.AceEditor;\n      const ReactResizeDetector = universe.ReactResizeDetector;\n      const RecreateChildOnPropsChange = universe.RecreateChildOnPropsChange;\n      \n      const Router = universe.ReactRouterDomRouter;\n      const Route = universe.ReactRouterDomRoute;\n      const Switch = universe.ReactRouterDomSwitch;\n      \n      \n      universe.sharedServices.logout = async ()=>{\n      \n        // TODO: use dataFilter \n        \n        let all = await universe.searchMemory({\n          filter: {\n            sqlFilter: {\n              nodeId: null\n            }\n          }\n        });\n        all = all.filter(n=>{return n.type != 'app_base:Qmtesting'});\n        \n        for(let node of all){\n          await universe.removeNode(node._id);\n        }\n        \n        return true;\n        \n      }\n      \n      WINDOW.getStellarServer = function(network){\n        \n        network = network || 'test';\n        \n        /// setup stellar connection \n        let horizonPossible = {\n          public: {\n            name: 'PubNet',\n            address: 'https://horizon.stellar.org',\n            network: 'public'\n          },\n          test: {\n            name: 'TestNet',\n            address: 'https://horizon-testnet.stellar.org',\n            network: 'test'\n          }\n        };\n      \n        let stellarInfo = horizonPossible[network];\n        switch(stellarInfo.network){\n          case 'public':\n            universe.StellarSdk.Network.usePublicNetwork();\n            break;\n          case 'test':\n            universe.StellarSdk.Network.useTestNetwork();\n            break;\n          default:\n            break;\n        }\n        \n        WINDOW.lastStellarInfo = stellarInfo;\n        let stellarServer = new universe.StellarSdk.Server(stellarInfo.address);\n        return stellarServer;\n        \n      }\n      \n      WINDOW.getIpfsValue = function(hash){\n        console.log('getIpfsValue:', hash);\n        \n        return new Promise(async (resolve,reject)=>{\n          \n          console.log('fetching ipfs hash:', hash); \n          \n          // just use ipfs.io \n          universe.fetch('https://ipfs.io/ipfs/' + hash)\n          .then(function(res){\n            console.log('from IPFS.io:', res);\n            return res.text();\n          })\n          .then(function(textResult){\n            resolve(textResult);\n          })\n          .catch(function(){\n            console.error('Failed loading IPFS hash from ipfs.io');\n            reject();\n          })\n          \n          \n          // let thisIpfs = WINDOW.existingIpfs;\n          // if(!thisIpfs){\n          //   thisIpfs = new WINDOW.Ipfs();\n          //   WINDOW.existingIpfs = thisIpfs;\n          // }\n          \n          // try {\n          //   thisIpfs.files.cat(hash, (err, res)=>{\n          //     console.log('localIpfsValue result:', err, res);\n          //     // console.log('Hash:', res[0].hash);\n          //     resolve(res.toString());\n          //   });\n          // }catch(err){\n          //   console.error('ipfs value failure:', err)\n          //   reject();\n          // }\n          \n        });\n      }\n      \n      \n      class EmbeddedComponent extends React.Component {\n        constructor(props){\n          super(props);\n        }\n        \n        render(){\n          return (\n            <div>\n              embeddedComponenthere\n            </div>\n          )\n        }\n      }\n      \n      let ErrorComponent = (name) => {\n        return class ErrorComponent extends React.Component {\n          constructor(props){\n            super(props);\n          }\n          render(){\n            return (\n              <div>\n                ErrorLoading: {name || 'unknown'}\n              </div>\n            )\n          }\n        }\n      }\n      \n      class mycomponent extends React.Component {\n        constructor(props){\n          super(props);\n          \n          WINDOW.appBaseUrl = WINDOW.appBaseUrl || '/identity';\n          \n          this.state = {\n            username: '', // will be normalized! \n            inviteCode: '',\n          }\n          \n          WINDOW.UpdateApp = this.handleUpdateApp;\n          \n          // listen for login changes \n          universe.EE.on('recheck-login', this.recheckLogin);\n          \n        }\n        \n        componentDidMount(){\n          \n          console.log('MainComponent didMount');\n          \n          this.startUp();\n            \n        }\n        \n        @autobind\n        async startUp(){\n          \n          await this.loadComponents();\n          \n          // See if username/passphrase is already saved locally \n          await this.fetchDefaultNodes();\n          \n          \n          // if identity includes a logged-in profile\n          // - show the main page (creating routes) \n          // - else: \n          //   - show login/register page (todo: include invite code automatically) \n          await this.checkAccountLoggedIn();\n          \n          console.log('MainComponent loaded startUp');\n        \n        }\n        \n        @autobind\n        async recheckLogin(){\n          await this.fetchDefaultNodes();\n          await this.checkAccountLoggedIn();\n        }\n        \n        @autobind\n        async handleUpdateApp(){\n          \n          // update local app_base from remote app_base \n          // - updates each node, according to name/path (NOT id) \n          \n          this.props.setState({\n            updatingLocal: true\n          });\n          \n          let localAppBases = await universe.searchMemory({\n            filter: {\n              filterNodes: tmpNodes=>{\n                // this runs isolated, outside of the above context? (not sure) \n                return new Promise((resolve, reject)=>{\n                  tmpNodes = tmpNodes.filter(tmpNode=>{\n                    if(tmpNode.nodeId){\n                      return false;\n                    }\n                    if(tmpNode.type.split(':')[0] != 'app_base'){\n                      return false;\n                    }\n                    return true;\n                  });\n                  resolve(tmpNodes);\n                });\n              },\n            }\n          });\n          let localAppBase = localAppBases[0];\n          \n          console.log('localAppBase:',localAppBase);\n          \n          // Get app_base from remote \n          let remoteAppBaseNode;\n          let remoteNodes;\n        \n          try {\n            \n            // use specified app, or determine from connected-to app? \n            // - usually specified now \n            if(WINDOW.limitedToAppZip){\n              // using specified\n              remoteNodes = await this.fetchNodesFromUrl(WINDOW.limitedToAppZip);\n              \n            } \n            // else {\n            //   // NOT specified (find, then run) \n              \n            //   let findResponse = await universe.loadAndRunCapability('TalkToSecond',{},{\n            //     type: 'standard_capability_action:0.0.1:local:298j291bs',\n            //     data: {\n            //       action: 'send',\n            //       options: {\n            //         ExternalIdentityNode: this.props.state.OwnerSecondExternalIdentityNode,\n            //         RequestNode: {\n            //           type: 'run_action_sequence:0.0.1:local:293fh8239hsdf23f',\n            //           data: {\n            //             actions: [\n            //               {\n            //                 matchActionType: 'search_internal_datasource:0.0.1:local:2h3ufih8s9h2f',\n            //                 dataForAction: {\n            //                   type: 'standard_query_request:0.0.1:local:65723f2khfds',\n            //                   data: {\n            //                     dataFilter: {\n            //                       nodeId: null\n            //                     },\n            //                     matchFunctionNode: {\n            //                       // query here!\n            //                       // action_pointer:0.0.1:local:238972ncr\n            //                       type: 'code_miniverse:0.0.1:local:2782fh8823s23',\n            //                       data: {\n            //                         code: `(()=>{\n            //                           // Action \n            //                           // - childNode common_type:0.0.1:local:298fh29h2323f == \"action\" \n                                      \n            //                           let inputNode = INPUT.data.inputNode;\n                                      \n            //                           if(inputNode.nodeId){\n            //                             return false;\n            //                           }\n                                      \n            //                           if(inputNode.type.split(':')[0] != 'app_base'){\n            //                             return false;\n            //                           }\n            //                           if(inputNode.name != '${localAppBase.name}'){\n            //                             return false;\n            //                           }\n                                      \n            //                           // Only return children platform_nodes for \"browser\" \n            //                           inputNode.nodes = inputNode.nodes.filter(node=>{\n            //                             if(node.type.split(':')[0] == 'platform_nodes' && \n            //                               node.data.platform != 'browser'){\n            //                                 return false;\n            //                             }\n            //                             return true;\n            //                           });\n                                      \n            //                           return inputNode;\n                                      \n            //                         })()`\n            //                       }\n            //                     }\n            //                   }\n            //                 }\n            //               }\n            //             ]\n                        \n            //           }\n            //         }\n            //       }\n            //     }\n            //   });\n              \n            //   // let nodes = universe.lodash.find(response.data.actionResponses[0].data[0].nodes,{type: 'code:0.0.1:local:32498h32f2'});\n            //   remoteNodes = findResponse.data.actionResponses[0].data;\n            // }\n            \n            // expecting a single result!\n            remoteAppBaseNode = remoteNodes[0];\n            \n            console.log('App nodes on Remote:', remoteNodes);\n            \n          }catch(err){\n            console.error('Failed getting local nodes', err);\n            return;\n          }\n          \n          \n          // Delete local app_base\n          console.log('Delete localAppBase');\n          await universe.removeNode(localAppBase._id);\n          \n          // Forcing updates at the moment (overwriting local app_base entirely) \n          // - TODO: show a diff! \n          // - TODO: only overwrite platform_nodes where platform=browser ? \n          \n              \n          console.log('Save remoteAppBase to local');\n          const saveChildNodes = (nodeId, childNodes) => {\n            return new Promise(async (resolve, reject)=>{\n    \n              console.log('Saving children');\n              \n              for(let tmpNode of childNodes){\n                let newChildNode = {\n                  nodeId,\n                  name: tmpNode.name,\n                  type: tmpNode.type,\n                  data: tmpNode.data,\n                }\n                let savedChildNode = await universe.newNode(newChildNode);\n                console.log('savedChildNode', savedChildNode);\n                if(tmpNode.nodes && tmpNode.nodes.length){\n    \n                  await saveChildNodes(savedChildNode._id, tmpNode.nodes || []);\n    \n                }\n              }\n              resolve();\n            });\n          }\n          await saveChildNodes(null, [remoteAppBaseNode]);\n          \n          console.log('Completed local update');\n          \n          this.props.setState({\n            updatingLocal: false\n          });\n          \n          // Could reload all? \n          // let answer = WINDOW.prompt('Reload?');\n          // if(answer){\n            setTimeout(()=>{\n              WINDOW.location.reload();\n            },1000);\n          // }\n          \n        }\n        \n        @autobind\n        fetchNodesFromUrl(url){\n          \n          // returns [expected: app_base] nodes from URL \n          \n          return new Promise(async (resolve,reject)=>{\n            \n            // converts startup git url into username/password \n            // - eventually allow links to be pasted, parse accordingly \n            \n            let ZipNodes;\n            \n            // parse github links and re-organize to fit .zip model \n        \n            this.setState({\n              fetchingNodes: true\n            });\n            \n            if(url.indexOf('github') > -1){\n\n              \n              let gh = universe.parseGitHubUrl(url);\n              if(gh.owner && \n                gh.name && \n                gh.repo && \n                gh.branch){\n                url = `https://github.com/${gh.repo}/archive/${gh.branch}.zip`;\n              }\n          \n              // cannot simply follow github zipball/tarball links :( \n              universe.fetch(`https://cors-anywhere.herokuapp.com/${url}`,{\n                // mode: 'no-cors' \n              })\n              .then(response=>{\n                // console.log('Response:', response);\n                return response.arrayBuffer();\n              })\n              .then(universe.JSZip.loadAsync)\n              .then(async (zip)=>{\n                \n                console.log('loaded zip data!', zip);\n        \n                // ZIP is valid! \n                let files = zip.files;\n        \n                function readFilePath(p){\n                  return new Promise(async (resolve,reject)=>{\n                    console.log('path:', p);\n                    let r = await files[p].async('text')\n                    resolve(r);\n                  });\n                }\n        \n                // load all the files \n                let allFiles = {};\n                for(let filepath of Object.keys(files)){\n                  let file = files[filepath];\n                  if(file.dir){\n        \n                  } else {\n                    // console.log('filepath:', filepath);\n                    let contents = await readFilePath(filepath);\n                    // console.log('contents:', contents);\n                    let normalizedPath = filepath.split('/').splice(1).join('/');\n                    allFiles[normalizedPath] = contents;\n                  }\n                }\n        \n                console.log('allFiles from Zip:', allFiles);\n                \n                function addChildren(id){\n                  return new Promise(async (resolve,reject)=>{\n              \n                    let nodes = [];\n                      for(let filepath of Object.keys(allFiles)){\n                      let contents = allFiles[filepath];\n                      if(filepath.indexOf('nodes/') !== 0){\n                        // console.log('NOT NODE:', filepath);\n                        continue;\n                      }\n        \n                      let parsed = jsonParse(filepath, contents);\n                      if(parsed.nodeId == id){\n                        // console.log('Matches ID:', parsed.nodeId, id);\n                        let children = await addChildren(parsed._id);\n                        parsed.nodes = children;\n                        nodes.push(parsed);\n                      } else {\n                        // console.log('No Kids:', id, parsed.nodeId);\n                      }\n        \n                    }\n        \n                    resolve(nodes);\n        \n                  });\n                }\n        \n                // re-organize child nodes \n                try {\n                  ZipNodes = await addChildren(null); // start at root, adds children recursively \n                }catch(err){\n                  console.error('Failed zipnodes', err);\n                  WINDOW.alert('Failed fetching zip nodes');\n                }\n          \n                console.log('ZipNodes:', ZipNodes);\n                \n                // let secondJson = JSON.parse(allFiles['second.json']);\n                // let basicKey = secondJson.name; \n                \n                this.setState({\n                  fetchingNodes: false\n                });\n                \n                return resolve(ZipNodes);\n        \n              })\n              \n            } else {\n              \n              console.log('Fetching second-hosted app url');\n        \n              // second-hosted app url \n              // - NOT zipped! \n              universe.fetch(url,{\n                // mode: 'no-cors' \n              })\n              .then(response=>{\n                console.log('Second App Response:', response);\n                // return response.arrayBuffer();\n                return response.json();\n              })\n              .then(appBaseJson=>{\n                console.log('appBaseJson', appBaseJson);\n        \n                ZipNodes = [appBaseJson];\n                    \n                this.setState({\n                  fetchingNodes: false\n                });\n                \n                return resolve(ZipNodes);\n                \n              });\n            }\n\n            \n          });\n          \n        }\n        \n        @autobind\n        checkAccountLoggedIn(){\n          // handling multiple starting states \n          \n          console.log('checkAccountLoggedIn');\n          \n          return new Promise(async (resolve,reject)=>{\n              \n            // update the token for the local user\n            let UsernamePassphraseNode = this.props.state.UsernamePassphraseNode;\n            if(!UsernamePassphraseNode){\n              console.log('No username/passphrase set yet');\n              return;\n            }\n            \n            this.props.setState({\n              renderMain: true\n            })\n            \n          });\n        \n          \n        }\n        \n        \n        @autobind\n        async loadComponents(){\n          \n          // Not async for setState! \n          \n          let components = [\n            'DefaultLayout',\n            'MainHomeComponent',\n            'PartialCreateComponent',\n            'PartialLoginComponent',\n            'Main404Component'\n          ];\n          \n          for(let componentInternalId of components){\n            try {\n                \n              let Component = await this.props.loadComponent({\n                internalId: componentInternalId\n              });\n              let obj = {};\n              obj[componentInternalId] = Component;\n              this.setState(obj)\n              // console.log(componentInternalId,Component);\n              \n            }catch(err){\n              console.error(\"Failed loading component:\",componentInternalId);\n            }\n          }\n          \n        }\n        \n        @autobind\n        fetchDefaultNodes(){\n          // nodes used elsewhere in the app \n          \n          return new Promise(async (resolve,reject)=>{\n              \n            // Cloud Second's main identity, from internal \n            let UsernamePassphraseNodes = await universe.searchMemory({\n              filter: {\n                sqlFilter: {\n                  type: 'username_passphrase:Qm3298f',\n                  // data: {\n                  //   commonName: 'main'\n                  // }\n                }\n              }\n            });\n            if(UsernamePassphraseNodes.length){\n              let UsernamePassphraseNode = UsernamePassphraseNodes[0];\n              \n              this.props.setState({\n                UsernamePassphraseNode\n              }, resolve);\n            } else {\n              resolve();\n            }\n            \n          });\n          \n        }\n        \n        @autobind\n        renderCreateComponent(){\n        \n          const PartialCreateComponent = this.state.PartialCreateComponent || ErrorComponent('PartialCreateComponent');\n          const PartialLoginComponent = this.state.PartialLoginComponent || ErrorComponent('PartialLoginComponent');\n          \n          return (\n            <div className=\"section\">\n              <div className=\"container\">\n                \n                <div className=\"columns\">\n                  <div className=\"column is-5 is-offset-2\">\n                    <h2 className=\"title is-3\">\n                      Second: <span style={{fontWeight:'normal'}}>Identity and Routing</span>\n                    </h2>\n                  </div>\n                </div>\n                \n                <br />\n              \n                <div className=\"columns\">\n                  <div className=\"column is-5 is-offset-2\" style={{borderRight:'1px solid #ccc'}}>\n                    \n                    <PartialCreateComponent />\n                    \n                  </div>\n                  \n                  <div className=\"column is-3\">\n                    <PartialLoginComponent />\n                  </div>\n                  \n                </div>\n                \n                <br />\n                <br />\n                \n                <div className=\"has-text-centered\">\n                  <a href=\"/about\">\n                    About Second (how it works)\n                  </a>\n                </div>\n                \n              </div>\n            </div>\n          );\n            \n        }\n        \n        render(){\n          \n          const DefaultLayout = this.state.DefaultLayout || ErrorComponent('DefaultLayout');\n          const MainHomeComponent = this.state.MainHomeComponent || ErrorComponent('MainHomeComponent');\n          const Main404Component = this.state.Main404Component || ErrorComponent('Main404Component');\n          \n          if(!this.props.state.renderMain){\n            return this.renderCreateComponent();\n          }\n          \n          return (\n            <Router basename={WINDOW.appBaseUrl}>\n              <Switch>\n              \n                <DefaultLayout exact path=\"/\" component={MainHomeComponent} />\n                \n                {/* Fallback (404) */}\n                <DefaultLayout path=\"/\" component={Main404Component} />\n                \n              </Switch>\n            </Router>\n          )\n        }\n      }\n      \n      mycomponent = universe.ReactGlobalState(mycomponent);\n      mycomponent = universe.ReactHelpers(mycomponent);\n      \n      resolve({\n        type: 'react_component:0.0.1:local:98912hd89',\n        data: mycomponent\n      });\n      \n    }catch(err){\n      reject({\n        ERROR: true, \n        err: err.toString()\n      });\n    }\n    \n  })\n\n  \n})()",
    "internalId": "MainComponent"
  }
}