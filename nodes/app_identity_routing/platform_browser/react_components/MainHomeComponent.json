{
  "type": "react_component:0.0.1:local:98912hd89",
  "name": "MainHomeComponent",
  "data": {
    "author": "-----BEGIN PUBLIC KEY-----\nMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCcuXovU+RZy85KMqLakYSH1mdV\nWdpEUtgcXUyGyU5hVeTO7BkV/kxeC2upcxOwNnrBOdsvHI3nrrILgt90/hCSHKzx\nhOFLREorGoKtSEHxI7/SnzzlWtV3gT/IP5GVHIyvuJBx3hCti0dH55DZG8iMGZ2y\ncGpV73Dez3hHmeBh6wIDAQAB\n-----END PUBLIC KEY-----",
    "version": "1",
    "key": "1424caa3-2102-49dc-abf6-6aef966076f2",
    "code": "(()=>{\n  return new Promise(async (resolve,reject)=>{\n    try {\n      \n      const AceEditor = universe.AceEditor;\n      const ReactResizeDetector = universe.ReactResizeDetector;\n      const RecreateChildOnPropsChange = universe.RecreateChildOnPropsChange;\n      \n      let ErrorComponent = (name) => {\n        return class ErrorComponent extends React.Component {\n          constructor(props){\n            super(props);\n          }\n          render(){\n            return (\n              <div>\n                ErrorLoading: {name || 'unknown'}\n              </div>\n            )\n          }\n        }\n      }\n      \n      \n      let horizonPossible = {\n        'id:': 'https://horizon.stellar.org',\n        'idtest:': 'https://horizon-testnet.stellar.org',\n        'second:': 'https://horizon-testnet.stellar.org'\n      }\n      \n      function getIpfsHash(str){\n        // Not used, using createIpfsHash instead \n        return new Promise(async (resolve,reject)=>{\n          \n          let buf = universe.Buffer.from(str,'utf8');\n          let mhash = await universe.MultiHash.getMultiHash(buf);\n          \n          resolve(mhash);\n          \n          // let thisIpfs = WINDOW.existingIpfs;\n          // if(!thisIpfs){\n          //   thisIpfs = new WINDOW.Ipfs();\n          //   WINDOW.existingIpfs = thisIpfs;\n          // }\n          \n          // try {\n          //   thisIpfs.files.add(new thisIpfs.types.Buffer(str, 'utf8'), {\n          //     onlyHash: true\n          //   }, (err, res)=>{\n          //     console.log('localIpfsHash result:', err, res);\n          //     console.log('Hash:', res[0].hash);\n          //     resolve(res[0].hash);\n          //   });\n          // }catch(err){\n          //   console.error('ipfs buffer failure:', err)\n          //   reject();\n          // }\n          \n        });\n      }\n      \n      function getIpfsValue(hash){\n        console.log('getIpfsValue:', hash);\n        \n        return new Promise(async (resolve,reject)=>{\n          \n          console.log('fetching ipfs hash:', hash); \n          \n          // just use ipfs.io \n          universe.fetch('https://ipfs.io/ipfs/' + hash)\n          .then(function(res){\n            console.log('from IPFS.io:', res);\n            return res.text();\n          })\n          .then(function(textResult){\n            resolve(textResult);\n          })\n          .catch(function(){\n            console.error('Failed loading IPFS hash from ipfs.io');\n            reject();\n          })\n          \n          \n          // let thisIpfs = WINDOW.existingIpfs;\n          // if(!thisIpfs){\n          //   thisIpfs = new WINDOW.Ipfs();\n          //   WINDOW.existingIpfs = thisIpfs;\n          // }\n          \n          // try {\n          //   thisIpfs.files.cat(hash, (err, res)=>{\n          //     console.log('localIpfsValue result:', err, res);\n          //     // console.log('Hash:', res[0].hash);\n          //     resolve(res.toString());\n          //   });\n          // }catch(err){\n          //   console.error('ipfs value failure:', err)\n          //   reject();\n          // }\n          \n        });\n      }\n      \n            \n      // https://lollyrock.com/articles/nodejs-encryption/\n      function encryptToString(text, password){\n        return new Promise(async (resolve,reject)=>{\n          var algorithm = 'aes-256-ctr';\n          var cipher = universe.crypto.createCipher(algorithm,password)\n          var crypted = cipher.update(text,'utf8','hex')\n          crypted += cipher.final('hex');\n          console.log('crypted', text, crypted);\n          resolve(crypted);\n        });\n      }\n      function decryptToString(text, password){\n        return new Promise(async (resolve,reject)=>{\n          var algorithm = 'aes-256-ctr';\n          var decipher = universe.crypto.createDecipher(algorithm,password)\n          var dec = decipher.update(text,'hex','utf8')\n          dec += decipher.final('utf8');\n          resolve(dec);\n        });\n      }\n      \n      \n      class mycomponent extends React.Component {\n        constructor(props){\n          super(props);\n          \n          // let thisIpfs = WINDOW.existingIpfs;\n          // if(!thisIpfs){\n          //   thisIpfs = new WINDOW.Ipfs();\n          //   WINDOW.existingIpfs = thisIpfs;\n          // }\n          \n          this.state = {\n            // stellarKey: '',\n            // routeText: 'id://nick/test1',\n            stellarKey: this.props.state.UsernamePassphraseNode.data.passphrase, \n            routeHost: 'second://' + this.props.state.UsernamePassphraseNode.data.username, // omits trailing '/' if routeText is empty\n            routeText: '', // should default to \"/\" or be in routeHost?\n            isSearching: false,\n            dataValue: '',\n            canParse: true,\n            isSaving: false,\n            usernameClaimable: false,\n            usernameOwnedByMe: true,\n            \n            connectedColor: 'yellow',\n            \n            routesRemaining: 7 // TODO: calculate from stellar balance! \n          }\n        }\n        \n        componentDidMount(){\n          \n          console.log('Loaded interface', this);\n            \n          // PeerJs server \n          const script = WINDOW.document.createElement(\"script\");\n          script.src = \"https://cdnjs.cloudflare.com/ajax/libs/peerjs/0.3.16/peer.min.js\";\n          script.async = true;\n          WINDOW.document.body.appendChild(script);\n            \n          if(this.props.initEditComponent){\n            this.props.initEditComponent(this);\n          }\n          \n          this.startup();\n          \n        }\n        \n        @autobind\n        async startup(){\n          \n          await this.loadComponents();\n          \n          this.updateRouteFullPath();\n          \n          this.checkIpfsConnected();\n          \n        }\n        \n        @autobind\n        async loadComponents(){\n          \n          // Not async for setState! \n          \n          // let components = [\n          //   'MainProfileComponent',\n          //   'MainSitesComponent',\n          //   'MainPostsComponent',\n          //   'MainMarketplaceComponent',\n          // ];\n          \n          // for(let componentInternalId of components){\n          //   try {\n                \n          //     let Component = await this.props.loadComponent({\n          //       internalId: componentInternalId\n          //     });\n          //     let obj = {};\n          //     obj[componentInternalId] = Component;\n          //     this.setState(obj)\n          //     // console.log(componentInternalId,Component);\n              \n          //   }catch(err){\n          //     console.error(\"Failed loading component:\",componentInternalId);\n          //   }\n          // }\n          \n        }\n        \n        @autobind\n        async logout(){\n          \n          await universe.removeNode(this.props.state.UsernamePassphraseNode._id);\n          \n          WINDOW.location.reload();\n          \n        }\n        \n        @autobind\n        async checkIpfsConnected(){\n          \n          console.log('checkIpfsConnected');\n          \n          let connectedColor = 'yellow';\n          \n          this.setState({\n            connectedColor\n          });\n          \n          let response = await universe.fetch('/ipfs-connected',{\n            method: 'POST',\n            headers: {\n                \"Content-Type\": \"application/json\", // charset=utf-8\n            }\n          })\n          console.log('Response:', response);\n          \n          let responseJson = await response.json();\n          \n          console.log('responseJson', responseJson);\n          \n          if(responseJson.data){\n            connectedColor = 'green';\n          } else {\n            connectedColor = 'red';\n          }\n          \n          this.setState({\n            connectedColor\n          });\n          \n          \n        }\n        \n        @autobind\n        async setupOrbitDb(){\n          \n          console.log('setupOrbitDb');\n          \n          // setup an orbit db \n          // - stored in localstorage? \n                    \n          // OrbitDB uses Pubsub which is an experimental feature\n          // and need to be turned on manually.\n          // Note that these options need to be passed to IPFS in\n          // all examples even if not specfied so.\n          var ipfsOptions = {\n              repo: '/orbitdb/examples/browser/new/ipfs/0.27.3',\n              start: true,\n              EXPERIMENTAL: {\n                pubsub: true,\n              },\n              config: {\n                Addresses: {\n                  Swarm: [\n                    // Use IPFS dev signal server\n                    // '/dns4/star-signal.cloud.ipfs.team/wss/p2p-webrtc-star',\n                    '/dns4/ws-star.discovery.libp2p.io/tcp/443/wss/p2p-websocket-star',\n                    // Use local signal server\n                    // '/ip4/0.0.0.0/tcp/9090/wss/p2p-webrtc-star',\n                  ]\n                },\n              }\n          }\n          \n          // Create IPFS instance\n          const ipfs = new WINDOW.Ipfs(ipfsOptions)\n          \n          console.log('Got ipfs');\n          \n          try {\n          \n            ipfs.on('error', function(e){console.error(e)})\n            ipfs.on('init', function(e){console.log('init', e)})\n            ipfs.on('start', function(e){console.log('start', e)})\n            ipfs.on('ready', async () => {\n              \n              console.log('Ready');\n              \n              const orbitdb = new WINDOW.OrbitDB(ipfs)\n              WINDOW.odb = orbitdb;\n            \n              // Create / Open a database\n              const db = await orbitdb.log('hello')\n              await db.load()\n              \n              console.log('orbit log db loaded');\n              WINDOW.odblog = db;\n            \n              // Listen for updates from peers\n              db.events.on('replicated', (address) => {\n                console.log(db.iterator({ limit: -1 }).collect())\n              })\n            \n              // Add an entry\n              const hash = await db.add('world')\n              console.log('hash:', hash)\n            \n              // Query\n              const result = db.iterator({ limit: -1 }).collect()\n              console.log('query:', JSON.stringify(result, null, 2))\n            })\n          }catch(err){\n            console.error(err);\n          }\n          \n\n        }\n        \n        @autobind\n        updateRouteFullPath(){\n          \n          let {\n            routeHost,\n            routeText\n          } = this.state;\n          \n          routeText = routeText.trim();\n          \n          if(!routeText.length){\n            // routeHost = routeHost;\n          } else {\n            if(routeText.substring(0,1) != '/'){\n              routeText = '/' + routeText;\n            }\n          }\n          \n          let routeFullPath = routeHost + routeText;\n          \n          console.log('routeFullPath', routeFullPath);\n          \n          this.setState({\n            routeFullPath\n          })\n        }\n        \n        @autobind\n        handleSearchKeyDown(e){\n        \n          if(e.key && e.key.toLowerCase() == 'enter'){\n            \n            this.handleSearch();\n            \n          } \n        }\n        \n        @autobind\n        handleTextareaKeydown(e){\n        \n          let nodeData = this.state.dataValue; \n          try {\n            nodeData = universe.dirtyJSON.parse(nodeData);\n            \n            this.setState({\n              canParse: true\n            });\n            \n          }catch(err){\n            this.setState({\n              canParse: false\n            });\n          }\n          \n        } \n        \n        @autobind\n        async handleSearch(){\n          console.log('searching');\n          \n          // stellar key should be pasted in \n          let stellarKey = this.state.stellarKey;\n          \n          // let routeText = this.state.routeText;\n          let routeFullPath = this.state.routeFullPath;\n          \n          this.setState({\n            isSearching: true,\n            failedSearch: false\n          });\n          \n          try {\n            // parse route \n            // - parse twice, second time probably using http, cuz id/idtest are not recognized protocols yet \n            let parser;\n            if(typeof WINDOW != 'undefined'){\n              parser = WINDOW.document.createElement('a');\n              parser.href = routeFullPath; \n            } else {\n              const { URL } = universe.require('url');\n              parser = new URL(routeFullPath);\n            }\n            \n            let protocol = parser.protocol;\n            switch(protocol){\n              case 'id:':\n              case 'idtest:':\n              case 'second:':\n                parser.protocol = 'http:';\n                break;\n              \n              default:\n                WINDOW.alert('Invalid protocol. please use id:// or idtest:// or second://');\n                return false;\n            }\n            \n            let baseIdentity = parser.host;\n            let subname = parser.username || '';\n            let password = parser.password.length ? parser.password : null;\n            let routePath = parser.pathname ? parser.pathname.slice(1) : '';\n            \n            console.log('Parsed route:', {baseIdentity, subname, password, routePath});\n          \n            switch(protocol){\n              case 'id:':\n                universe.StellarSdk.Network.usePublicNetwork();\n                break;\n              case 'idtest:':\n                universe.StellarSdk.Network.useTestNetwork();\n                break;\n              case 'second:':\n                universe.StellarSdk.Network.useTestNetwork();\n                break;\n              default:\n                console.error('Invalid protocol');\n                return;\n            }\n            \n            let stellarServer = new universe.StellarSdk.Server(horizonPossible[protocol]);\n            \n            console.log('stellarServer', stellarServer);\n            \n            let usernameSeed = universe.crypto.createHash('sha256').update(baseIdentity).digest(); //returns a buffer\n            console.log('usernameSeed', usernameSeed);\n            \n            var pairForIdentity = universe.StellarSdk.Keypair.fromRawEd25519Seed(usernameSeed);\n            \n          \n            console.log('pairForIdentity', pairForIdentity);\n            \n            this.setState({\n              usernameClaimable: false,\n              usernameOwnedByMe: false\n            });\n            \n            let identityAccount;\n            try {\n              identityAccount = await stellarServer.loadAccount(pairForIdentity.publicKey())\n              console.log('identityAccount:', identityAccount);\n            }catch(err){\n              console.error('Failed getting identityAccount', err);\n              // WINDOW.alert('failed loading idenity');\n              \n              this.setState({\n                usernameClaimable: true\n              });\n            \n              throw 'Failed loading identity'\n            }\n            \n            // owned by me? \n            var pairSource = universe.StellarSdk.Keypair.fromSecret(this.state.stellarKey);\n            var pairSourcePublicKey = pairSource.publicKey();\n            for(let signer of identityAccount.signers){\n              if(signer.public_key == pairSourcePublicKey){\n                this.setState({\n                  usernameOwnedByMe: true\n                })\n              }\n            }\n            \n            let lookupPath = subname + '|' + routePath;\n            if(password){\n              lookupPath = password + '|' + subname + '|' + routePath;\n              // lookupPath = await encryptToString(subname + '|' + routePath, password+routePath)\n            }\n            \n            let lookupPathHash = universe.crypto.createHash('sha256').update(lookupPath).digest('hex'); \n             \n            \n            console.log('lookupPathHash', lookupPathHash);\n      \n            // get the ipfs value \n            let valueIpfsHash = await identityAccount.data({key: lookupPathHash})\n            .then(function(dataValue) {\n              let decoded = atob(dataValue.value);\n              return decoded;\n            })\n            .catch(function (err) {\n              console.error('ipfs error', err);\n              return null;\n            })\n            \n            console.log('Data Result:', valueIpfsHash);\n            if(!valueIpfsHash){\n              throw 'Missing data result'\n            }\n            \n            // Load IPFS data \n            let ipfsData = await getIpfsValue(valueIpfsHash);\n            \n            console.log('ipfsData:', ipfsData);\n            \n            let dec = ipfsData;\n            let actualValue = dec;\n            if(password){\n              console.log('had password'); \n              dec = await decryptToString(ipfsData, password+routePath);\n              console.log('decrypted1:', dec);\n              actualValue = await getIpfsValue(dec);\n              dec = await decryptToString(actualValue, password+routePath);\n              actualValue = dec;\n            }\n            \n            console.log('decrypted-same:', dec == actualValue ? true:false, dec, actualValue);\n            \n            \n            // expecting a Node type to be returned \n            let nodeData;\n            try {\n              nodeData = JSON.parse(actualValue);\n            }catch(err){\n              console.error('unable to parse nodedata');\n            }\n            \n            console.log('Final nodeData:', nodeData);\n            \n            this.setState({\n              dataValue: actualValue\n            });\n            \n          }catch(err){\n            // failed finding route data \n            console.error('Failed searching', err);\n            \n            this.setState({\n              failedSearch: true\n            })\n          \n          }\n          \n          this.setState({isSearching: false});\n          \n        }\n        \n        \n        @autobind\n        async addRouteData(e){\n          \n          // stellar key should be pasted in \n          let stellarKey = this.state.stellarKey;\n          \n          let nodeData = this.state.dataValue; // expecting a string, should be JSON.parse'able \n          \n          // try {\n          //   JSON.parse(nodeData);\n          // }catch(err){\n          //   WINDOW.alert('Invalid JSON specified');\n          //   return false;\n          // }\n          \n          // let routeText = this.state.routeText;\n          let routeFullPath = this.state.routeFullPath;\n          \n          this.setState({\n            isSaving: true,\n            failedSaving: false\n          });\n          \n          try {\n              \n            // parse route \n            // - parse twice, second time probably using http, cuz id/idtest are not recognized protocols yet \n            let parser;\n            if(typeof WINDOW != 'undefined'){\n              parser = WINDOW.document.createElement('a');\n              parser.href = routeFullPath; \n            } else {\n              const { URL } = universe.require('url');\n              parser = new URL(routeFullPath);\n            }\n            \n            let protocol = parser.protocol;\n            switch(protocol){\n              case 'id:':\n              case 'idtest:':\n              case 'second:':\n                parser.protocol = 'http:';\n                break;\n              \n              default:\n                WINDOW.alert('Invalid protocol. please use id:// or idtest:// or second://');\n                throw 'Invalid protocol'\n            }\n            \n            let baseIdentity = parser.host;\n            let subname = parser.username || '';\n            let password = parser.password.length ? parser.password : null;\n            let routePath = parser.pathname ? parser.pathname.slice(1) : '';\n            \n            console.log('Parsed route:', {baseIdentity, subname, password, routePath});\n            \n            console.log('nodeData:', nodeData);\n            \n            // encrypt data using password\n            if(password){\n              nodeData = await encryptToString(nodeData, password+routePath);\n            }\n            \n            console.log('encrypted NodeData:', nodeData);\n            \n            // create IPFS hashes of nodeData \n            let ipfsHashOfData = await this.createIpfsHashOnSecond(nodeData); // TODO \n            \n            console.log('ipfsHashOfData:', ipfsHashOfData);\n            \n            let encryptedDataToSave,\n              ipfsHashOfEncryptedData;\n            if(password){\n              // encrypt the ipfs hash using password+path \n              console.log('Using password for encryption');\n              encryptedDataToSave = await encryptToString(ipfsHashOfData, password+routePath); // TODO\n              ipfsHashOfEncryptedData = await this.createIpfsHashOnSecond(encryptedDataToSave); \n              console.log('ipfsHashOfEncryptedData:', ipfsHashOfEncryptedData);\n            }\n            \n            \n            // Add files and pin data to IPFS \n            // TODO \n            \n            \n            // Write to Stellar \n            console.log('Writing to stellar', protocol);\n          \n            switch(protocol){\n              case 'id:':\n                universe.StellarSdk.Network.usePublicNetwork();\n                break;\n              case 'idtest:':\n                universe.StellarSdk.Network.useTestNetwork();\n                break;\n              case 'second:':\n                universe.StellarSdk.Network.useTestNetwork();\n                break;\n              default:\n                console.error('Invalid protocol');\n                throw 'Invalid protocol'\n            }\n            \n            let stellarServer = new universe.StellarSdk.Server(horizonPossible[protocol]);\n            \n            console.log('stellarServer', stellarServer);\n            \n            let usernameSeed = universe.crypto.createHash('sha256').update(baseIdentity).digest(); //returns a buffer\n            console.log('usernameSeed', usernameSeed);\n            \n            var pairForIdentity = universe.StellarSdk.Keypair.fromRawEd25519Seed(usernameSeed);\n            \n            \n            // multi-sig address for updating \n            var pairForWrite = universe.StellarSdk.Keypair.fromSecret(stellarKey);\n            \n            \n            console.log('pairForIdentity', pairForIdentity);\n            \n            let identityAccount;\n            try {\n              identityAccount = await stellarServer.loadAccount(pairForIdentity.publicKey())\n              console.log('identityAccount:', identityAccount);\n            }catch(err){\n              console.error('Failed getting identityAccount', err);\n              WINDOW.alert('failed loading idenity');\n              throw 'Failed loading identity'\n            }\n            \n            // write the new data value \n            console.log('writing ipfs values to ipfs');\n             \n            let lookupPath = subname + '|' + routePath;\n            if(password){\n              lookupPath = password + '|' + subname + '|' + routePath;\n              // lookupPath = await encryptToString(subname + '|' + routePath, password+routePath)\n            }\n            \n            let lookupPathHash = universe.crypto.createHash('sha256').update(lookupPath).digest('hex'); \n            \n            let value = ipfsHashOfEncryptedData || ipfsHashOfData;\n            let name = lookupPathHash;\n            \n            console.log('name, value:', name, value);\n            \n            // Start building the transaction for manageData update\n            let transaction = new universe.StellarSdk.TransactionBuilder(identityAccount)\n            \n            .addOperation(universe.StellarSdk.Operation.manageData({\n              name, // just use /path ? \n              value // encrypted, if exists \n            }))\n            // .addMemo(StellarSdk.Memo.hash(b32))\n            .build();\n  \n            // Sign the transaction to prove you are actually the person sending it.\n            transaction.sign(pairForIdentity); // targetKeys\n            transaction.sign(pairForWrite); // sourceKeys\n  \n            // send to stellar network\n            let stellarResult = await stellarServer.submitTransaction(transaction)\n            .then(function(result) {\n              console.log('Stellar manageData Success! Results:'); //, result);\n              return result;\n            })\n            .catch(function(error) {\n              console.error('Stellar Something went wrong (failed updating data)!', error);\n              // If the result is unknown (no response body, timeout etc.) we simply resubmit\n              // already built transaction:\n              // server.submitTransaction(transaction);\n              return null;\n            });\n  \n            // console.log('stellarResult', stellarResult);\n  \n            if(!stellarResult){\n              console.error('Failed stellar manageData');\n              throw 'Failed stellar manageData'\n            }\n  \n            console.log('stellarResult succeeded! (manageData)');\n            \n            console.log('stellarResult', stellarResult);\n            \n          }catch(err){\n            // failed finding route data \n            console.error('Failed searching', err);\n            \n            this.setState({\n              failedAdd: true\n            })\n          \n          }\n          \n          this.setState({isSaving: false});\n          \n        }\n        \n        @autobind\n        async handleSendMessage(){\n          \n          // Get address to send to \n          // - expecting only one type of address (https) \n          \n          let upNode = this.props.state.UsernamePassphraseNode;\n          \n          let secondUrl = '/drop';\n          \n          let text = WINDOW.prompt('Text', 'text body of incoming message is this!!');\n          if(!text){\n            return false;\n          }\n          \n          let messageNode = {\n            type: 'signed_message:Qmtesting',\n            data: {\n              msgId: universe.uuidv4(), // for uniqueness\n              to: '', // TODO: encrypt for that username too? using a different pubkey? \n              from: upNode.data.username,\n              content: {\n                type: 'text:Qmtesting',\n                data: {\n                  text\n                }\n              },\n              sig: undefined,\n              // createdAt ? \n            }\n          }\n          \n          // Sign \n          // - order keys, stringify each value\n          var passwordPair = universe.StellarSdk.Keypair.fromSecret(this.state.stellarKey);\n          \n          let stringToSign = Object.keys(messageNode.data).sort().map(k=>JSON.stringify(messageNode.data[k])).join('');\n          console.log('stringToSign:',stringToSign);\n          \n          let sig = passwordPair.sign(stringToSign).toString('base64'); \n          \n          console.log('sig:', sig);\n          \n          // add signature to data \n          messageNode.data.sig = sig;\n          \n          let response = await universe.fetch(secondUrl, {\n            method: 'POST',\n            headers: {\n                \"Content-Type\": \"application/json\", // charset=utf-8\n            },\n            body: JSON.stringify(messageNode)\n          })\n          console.log('Response:', response);\n          \n          let responseJson = await response.json();\n          \n          console.log('responseJson', responseJson);\n          \n        }\n        \n        @autobind\n        handleViewAccount(){\n          \n          let stellarKey = this.state.stellarKey;\n          \n          let routePath = this.state.routePath;\n          \n          try {\n              \n            // parse route \n            // - parse twice, second time probably using http, cuz id/idtest are not recognized protocols yet \n            let parser;\n            if(typeof WINDOW != 'undefined'){\n              parser = WINDOW.document.createElement('a');\n              parser.href = routePath; \n            } else {\n              const { URL } = universe.require('url');\n              parser = new URL(routePath);\n            }\n            \n            let protocol = parser.protocol;\n            switch(protocol){\n              case 'id:':\n              case 'idtest:':\n              case 'second:':\n                parser.protocol = 'http:';\n                break;\n              \n              default:\n                WINDOW.alert('Invalid protocol. please use id:// or idtest:// or second://');\n                throw 'Invalid protocol'\n            }\n            \n            let baseIdentity = parser.host;\n            \n            let pkTargetSeed = universe.jsSHA256.array(baseIdentity);\n            var pairTarget = universe.StellarSdk.Keypair.fromRawEd25519Seed(pkTargetSeed);\n            \n            let href = `https://horizon-testnet.stellar.org/accounts/${pairTarget.publicKey()}`;\n            \n            WINDOW.open(href, '_blank');\n            \n            console.log('href:', href);\n          \n          }catch(err){\n            console.error('Failed finding identity link:', err);\n            \n          }\n        }\n        \n        @autobind\n        createIpfsHashOnSecond(fileValue){\n          // shared_node\n          // \n          return new Promise(async (resolve,reject)=>{\n              \n            try {\n              \n              this.setState({\n                isCreating: true\n              })\n              \n              // let response = await universe.loadAndRunCapability('TalkToSecond',{\n              //   type: 'default_loadandruncapability_options:Qmf239j',\n              //   data: {\n              //     skipSameAppPlatform: true\n              //   }\n              // },{\n              //   type: 'standard_capability_action:0.0.1:local:298j291bs',\n              //   data: {\n              //     action: 'send',\n              //     options: {\n              //       ExternalIdentityNode: this.props.state.OwnerSecondExternalIdentityNode,\n              //       RequestNode: {\n              //         type: 'run_action_sequence:0.0.1:local:293fh8239hsdf23f',\n              //         data: {\n              //           actions: [\n                          \n              //             {\n              //               matchActionType: 'identify_via_token:0.0.1:local:237823783g2123',\n              //               dataForAction: {\n              //                 type: 'string:...',\n              //                 data: this.props.state.OwnerSecondExternalIdentityNode.data.token\n              //               }\n              //             },\n                      \n              //             { \n              //               matchActionType: 'ipfs_file_add:Qmfmk230fjs',\n              //               dataForAction: {\n              //                 type: 'standard_query_request:0.0.1:local:65723f2khfds',\n              //                 data: {\n              //                   type: 'file_with_data_and_options:Qmdf23ifsmkmm',\n              //                   data: {\n              //                     options: {\n              //                       pin: true\n              //                     },\n              //                     fileValue\n              //                   }\n              //                 }\n              //               }\n              //             },\n                          \n              //           ]\n                        \n              //         }\n              //       }\n              //     }\n              //   }\n              // });\n              \n              // console.log('Response:', response);\n              \n              // let hash = response.data.actionResponses[1].data.hash;\n              \n              console.log('stellarKey:', this.state.stellarKey);\n              var passwordPair = universe.StellarSdk.Keypair.fromSecret(this.state.stellarKey);\n              \n              let sourcePublicKey = passwordPair.publicKey();\n              let sig = passwordPair.sign(fileValue).toString('base64'); //fileValue);\n              \n              console.log('sig:', sig, typeof sig);\n              \n              universe.fetch('/ipfs-pin',{\n                method: 'POST',\n                headers: {\n                    \"Content-Type\": \"application/json\", // charset=utf-8\n                },\n                body: JSON.stringify({\n                  username: this.state.inviteCode,\n                  sourcePublicKey, \n                  sig,\n                  fileAsString: fileValue\n                })\n              })\n              .then(response=>{\n                console.log('Response1:', response);\n                if(response.status == 200){\n                  return response;\n                }\n                // failed!\n                console.error('failed!', respones);\n                // this.setState({\n                //   generatingLumens: false,\n                //   lumensMessage: 'Failed populating seed wallet'\n                // })\n                // throw \"Failed populating seed wallet with Friendbot lumens\"\n                reject()\n              })\n              .then(response=>response.json())\n              .then(async (response)=>{\n                console.log('Response:', response);\n                \n                // Succeeded in creating ownership account for us to reserve the username \n                // - NOT creatinig username on server, just accepting the invite for controller account \n                //   - prevents passphrase from needing to go to the server (just send the pubkey!) \n                \n                if(response.data.success != true){\n                  console.error('Failed:', response.data);\n                  WINDOW.alert('Failed pinning IPFS data, please try again or contact support');\n                  reject();\n                  return false;\n                }\n                \n                console.log('success pinning!');\n                \n                let hash = response.data.hash || 'MISSING HASH';\n                \n                console.log('hash:', hash);\n                \n                resolve(hash);\n                \n                \n              })\n              .catch((err)=>{\n                console.error(err);\n                reject();\n              })\n                \n              \n              // // Pin! \n              // resolve(hash);\n              // // {\n              // //   type: 'ipfs_hash:Qmdflj',\n              // //   data: hash\n              // // });\n              \n            } catch(err){\n              console.error('Failed TalkToSecond request', err);\n              reject();\n            }\n          \n            this.setState({\n              isCreating: false\n            })\n            \n            \n            return;\n            \n          });\n          \n        }\n        \n        @autobind\n        handlePrettify(){\n          \n          let nodeData = this.state.dataValue; \n          try {\n            nodeData = universe.dirtyJSON.parse(nodeData);\n            \n            this.setState({\n              dataValue: JSON.stringify(nodeData, null, 2)\n            })\n            \n          }catch(err){\n          }\n          \n          \n        }\n        \n        render(){\n          \n          var hostUrl = WINDOW.location.protocol + \"//\" + WINDOW.location.host;\n          \n          return (\n        \n            <div className=\"section\">\n              <div className=\"container\">\n                <div className=\"columns\">\n                \n                  <div className=\"column is-6 is-offset-3\">\n                    \n                    <div className=\"columns\">\n                      <div className=\"column is-9\">\n                      \n                      \n                        <div className=\"title is-4\">\n                          {this.props.state.UsernamePassphraseNode.data.username}\n                        </div>\n                        <div className=\"subtitle is-6\">\n                          <strong>Passphrase: </strong>\n                          <span onClick={e=>{WINDOW.prompt('',this.props.state.UsernamePassphraseNode.data.passphrase)}}>{this.props.state.UsernamePassphraseNode.data.passphrase.substring(0,10)}...</span>\n                        </div>\n                        {/*\n                        <div>\n                          <span>Storage: 0.5GB</span>\n                        </div>\n                        <div>\n                          <span>Routes: {this.state.routesRemaining}</span>\n                        </div>\n                        */}\n                      \n                      </div>\n                      \n                      {/*<div className=\"column is-3\">\n                        <button className={\"button is-info \"} onClick={this.setupOrbitDb}>Setup Peer</button>\n                      </div>\n                      */}\n                      <div className=\"column is-3 has-text-right\">\n                        \n                        {/* status of ipfs */}\n                        <div \n                          style={{display:'inline-block',width:'50px',height:'4px',backgroundColor:this.state.connectedColor}}\n                          onClick={this.checkIpfsConnected}\n                        >\n                          &nbsp;\n                        </div>\n                        \n                        <br />\n                      \n                        <button className={\"button is-warning \"} onClick={this.logout}>Logout</button>\n                      </div>\n                      \n                        \n                      \n                    </div>\n                    \n                    <hr />\n                    \n                    {/* Route Input/Buttons */}  \n                    <div className=\"\">\n                    \n                      {/* Desktop version */}  \n                      <div className=\"is-hidden-touch\">\n                        <div className=\"field has-addons\">\n                          <div className=\"control\">\n                            <input className=\"input\" value={this.state.routeHost} onChange={e=>this.setState({routeHost:e.target.value}, this.updateRouteFullPath)} placeholder=\"\" disabled={true} />\n                          </div>\n                          <div className=\"control is-expanded\">\n                            <input className=\"input\" value={this.state.routeText} onChange={e=>this.setState({routeText:e.target.value}, this.updateRouteFullPath)} placeholder=\"\" onKeyDown={this.handleSearchKeyDown} />\n                          </div>\n                          <div className=\"control\">\n                            <button className={\"button is-info \" + (this.state.isSearching ? 'is-loading':'')} onClick={this.handleSearch}>Load Data For Route</button>\n                          </div>\n                          <div className=\"control\">\n                            <button className={\"button is-success \" + (this.state.isSaving ? 'is-loading':'')} \n                            onClick={this.addRouteData}\n                            disabled={!this.state.usernameOwnedByMe}\n                            >Save Data</button>\n                          </div>\n                          <div className=\"control\">\n                            <button className={\"button is-default \" + (this.state.isSending ? 'is-loading':'')} \n                            onClick={this.handleSendMessage}\n                            >Send Message</button>\n                          </div>\n                          \n                          {/* can be claimed? \n                          <div className=\"control\">\n                            <button className={\"button is-default \" + (this.state.isClaiming ? 'is-loading':'')} \n                            onClick={this.handleClaimUsername}\n                            disabled={!this.state.usernameClaimable}>Claim Username</button>\n                          </div>\n                          <div className=\"control\">\n                            <button className={\"button is-default \" + (this.state.isFunding ? 'is-loading':'')} onClick={this.handleFundAccount}>Add Funds</button>\n                          </div>\n                          \n                          \n                          <div className=\"control\">\n                            <button className={\"button is-default \"} onClick={this.handleViewAccount}>View Account</button>\n                          </div>\n                          \n                          <div className=\"control\">\n                            <button className={\"button is-default \"}>Change Private Key (SBKO...)</button>\n                          </div>\n                          */}\n                          \n                        </div>\n                      </div>\n                      \n                        \n                      {/* Mobile version*/}\n                      <div className=\"is-hidden-desktop\">\n                        \n                        <div className=\"field has-addons\">\n                          <div className=\"control is-expanded\">\n                            <input className=\"input\" value={this.state.routeHost} onChange={e=>this.setState({routeHost:e.target.value}, this.updateRouteFullPath)} placeholder=\"\" disabled={true} />\n                          </div>\n                        </div>\n                        <div className=\"field has-addons\">\n                          <div className=\"control is-expanded\">\n                            <input className=\"input\" value={this.state.routeText} onChange={e=>this.setState({routeText:e.target.value}, this.updateRouteFullPath)} placeholder=\"\" onKeyDown={this.handleSearchKeyDown} autocapitalize=\"off\" />\n                          </div>\n                        </div>\n                        <div className=\"field has-addons\">\n                          <div className=\"control\">\n                            <button className={\"button is-info \" + (this.state.isSearching ? 'is-loading':'')} onClick={this.handleSearch}>Load Data For Route</button>\n                          </div>\n                          <div className=\"control\">\n                            <button className={\"button is-success \" + (this.state.isSaving ? 'is-loading':'')} \n                            onClick={this.addRouteData}\n                            disabled={!this.state.usernameOwnedByMe}\n                            >Save Data</button>\n                          </div>\n                        </div>\n                      \n                      </div>\n                      \n                      \n                      <div>\n                        {\n                          !this.state.failedAdd ? '':\n                          <span className='has-text-danger'>\n                            Failed adding\n                          </span>\n                        }\n                        {\n                          !this.state.failedSearch ? '':\n                          <span className='has-text-danger'>\n                            Failed loading route data\n                          </span>\n                        }\n                        {\n                          !this.state.failedClaim ? '':\n                          <span className='has-text-danger'>\n                            Failed claiming identity\n                          </span>\n                        }\n                        {\n                          !this.state.failedFunding ? '':\n                          <span className='has-text-danger'>\n                            Failed funding\n                          </span>\n                        }\n                        &nbsp;\n                      </div>\n                      \n                    </div>\n                    \n                    <br />\n                    \n                    <div>\n                      \n                      <textarea \n                        className='textarea' \n                        onChange={e=>this.setState({dataValue: e.target.value})} \n                        onKeyDown={this.handleTextareaKeydown}\n                        value={this.state.dataValue} \n                        rows=\"10\" \n                      />\n                      \n                      <br />\n                    \n                      <div className=\"control\">\n                        <button \n                          className={\"button is-default \"} \n                          onClick={this.handlePrettify}\n                          disabled={!this.state.canParse}\n                        >Prettify JSON</button>\n                      </div>\n                    </div>\n                    \n                    <br />\n                    \n                    <div className=\"\">\n                      <span>\n                        Anyone can view the route's data by visiting: \n                        <br />\n                        <a href={`https://viewsecondroute.com/raw/${this.state.routeFullPath}`}>\n                          https://viewsecondroute.com/raw/{this.state.routeFullPath}\n                        </a> (server-side) \n                        <br />\n                        or \n                        <br />\n                        <a href={`https://viewsecondroute.com/view/${this.state.routeFullPath}`}>\n                          https://viewsecondroute.com/view/{this.state.routeFullPath}\n                        </a> (client-side) \n                      </span>\n                    </div>\n                    \n                    <br />\n                    <br />\n                    \n                    <button className={\"button is-default \"} onClick={()=>{WINDOW.UpdateApp()}}>Update</button>\n                    \n                    \n                  </div>\n                  \n                </div>\n                \n              </div>\n              \n            </div>\n            \n            \n          )\n        }\n      }\n      \n      if(universe.sharedComponents && universe.sharedComponents.withEditableNodeInfo){\n        mycomponent = universe.sharedComponents.withEditableNodeInfo(mycomponent, {\n          localNode: SELF,\n          localNodeIsRemote: true\n        });\n      }\n       \n      mycomponent = universe.ReactGlobalState(mycomponent);\n      mycomponent = universe.ReactHelpers(mycomponent);\n      \n      const styles = {\n        deleteIcon: {\n          position: 'absolute',\n          top: '0px',\n          right: '-24px',\n          cursor: 'pointer'\n        }\n      }\n      \n      resolve({\n        type: 'react_component:0.0.1:local:98912hd89',\n        data: mycomponent\n      });\n      \n    }catch(err){\n      reject({\n        ERROR: true, \n        err: err.toString()\n      });\n    }\n    \n  })\n\n  \n})()",
    "internalId": "MainHomeComponent"
  }
}