{
  "type": "react_component:0.0.1:local:98912hd89",
  "name": "MainHomeComponent",
  "data": {
    "author": "-----BEGIN PUBLIC KEY-----\nMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCcuXovU+RZy85KMqLakYSH1mdV\nWdpEUtgcXUyGyU5hVeTO7BkV/kxeC2upcxOwNnrBOdsvHI3nrrILgt90/hCSHKzx\nhOFLREorGoKtSEHxI7/SnzzlWtV3gT/IP5GVHIyvuJBx3hCti0dH55DZG8iMGZ2y\ncGpV73Dez3hHmeBh6wIDAQAB\n-----END PUBLIC KEY-----",
    "version": "1",
    "key": "1424caa3-2102-49dc-abf6-6aef966076f2",
    "code": "(()=>{\n  return new Promise(async (resolve,reject)=>{\n    try {\n      \n      const AceEditor = universe.AceEditor;\n      const ReactResizeDetector = universe.ReactResizeDetector;\n      const RecreateChildOnPropsChange = universe.RecreateChildOnPropsChange;\n      \n      let ErrorComponent = (name) => {\n        return class ErrorComponent extends React.Component {\n          constructor(props){\n            super(props);\n          }\n          render(){\n            return (\n              <div>\n                ErrorLoading: {name || 'unknown'}\n              </div>\n            )\n          }\n        }\n      }\n      \n      \n      let horizonPossible = {\n        'id:': 'https://horizon.stellar.org',\n        'idtest:': 'https://horizon-testnet.stellar.org',\n        'second:': 'https://horizon-testnet.stellar.org'\n      }\n      \n      function getIpfsHash(str){\n        // Not used, using createIpfsHash instead \n        return new Promise(async (resolve,reject)=>{\n          let thisIpfs = WINDOW.existingIpfs;\n          if(!thisIpfs){\n            thisIpfs = new WINDOW.Ipfs();\n            WINDOW.existingIpfs = thisIpfs;\n          }\n          \n          try {\n            thisIpfs.files.add(new thisIpfs.types.Buffer(str, 'utf8'), {\n              onlyHash: true\n            }, (err, res)=>{\n              console.log('localIpfsHash result:', err, res);\n              console.log('Hash:', res[0].hash);\n              resolve(res[0].hash);\n            });\n          }catch(err){\n            console.error('ipfs buffer failure:', err)\n            reject();\n          }\n          \n        });\n      }\n      \n      function getIpfsValue(hash){\n        return new Promise(async (resolve,reject)=>{\n          let thisIpfs = WINDOW.existingIpfs;\n          if(!thisIpfs){\n            thisIpfs = new WINDOW.Ipfs();\n            WINDOW.existingIpfs = thisIpfs;\n          }\n          \n          try {\n            thisIpfs.files.cat(hash, (err, res)=>{\n              console.log('localIpfsValue result:', err, res);\n              // console.log('Hash:', res[0].hash);\n              resolve(res.toString());\n            });\n          }catch(err){\n            console.error('ipfs value failure:', err)\n            reject();\n          }\n          \n        });\n      }\n      \n            \n      // https://lollyrock.com/articles/nodejs-encryption/\n      function encryptToString(text, password){\n        return new Promise(async (resolve,reject)=>{\n          var algorithm = 'aes-256-ctr';\n          var cipher = universe.crypto.createCipher(algorithm,password)\n          var crypted = cipher.update(text,'utf8','hex')\n          crypted += cipher.final('hex');\n          console.log('crypted', text, crypted);\n          resolve(crypted);\n        });\n      }\n      function decryptToString(text, password){\n        return new Promise(async (resolve,reject)=>{\n          var algorithm = 'aes-256-ctr';\n          var decipher = universe.crypto.createDecipher(algorithm,password)\n          var dec = decipher.update(text,'hex','utf8')\n          dec += decipher.final('utf8');\n          resolve(dec);\n        });\n      }\n      \n      \n      class mycomponent extends React.Component {\n        constructor(props){\n          super(props);\n          \n          let thisIpfs = WINDOW.existingIpfs;\n          if(!thisIpfs){\n            thisIpfs = new WINDOW.Ipfs();\n            WINDOW.existingIpfs = thisIpfs;\n          }\n          \n          this.state = {\n            // stellarKey: '',\n            // routeText: 'id://nick/test1',\n            stellarKey: this.props.state.UsernamePassphraseNode.data.passphrase, \n            routeHost: 'second://' + this.props.state.UsernamePassphraseNode.data.username,\n            routeText: '',\n            isSearching: false,\n            dataValue: '',\n            canParse: true,\n            isSaving: false,\n            usernameClaimable: false,\n            usernameOwnedByMe: false\n          }\n        }\n        \n        componentDidMount(){\n          \n          console.log('Loaded interface', this);\n            \n          if(this.props.initEditComponent){\n            this.props.initEditComponent(this);\n          }\n          \n          this.startup();\n            \n        }\n        \n        @autobind\n        async startup(){\n          \n          await this.loadComponents();\n          \n          this.updateRouteFullPath();\n          \n        }\n        \n        @autobind\n        async loadComponents(){\n          \n          // Not async for setState! \n          \n          // let components = [\n          //   'MainProfileComponent',\n          //   'MainSitesComponent',\n          //   'MainPostsComponent',\n          //   'MainMarketplaceComponent',\n          // ];\n          \n          // for(let componentInternalId of components){\n          //   try {\n                \n          //     let Component = await this.props.loadComponent({\n          //       internalId: componentInternalId\n          //     });\n          //     let obj = {};\n          //     obj[componentInternalId] = Component;\n          //     this.setState(obj)\n          //     // console.log(componentInternalId,Component);\n              \n          //   }catch(err){\n          //     console.error(\"Failed loading component:\",componentInternalId);\n          //   }\n          // }\n          \n        }\n        \n        @autobind\n        updateRouteFullPath(){\n          this.setState({\n            routeFullPath: this.state.routeHost + this.state.routeText\n          })\n        }\n        \n        @autobind\n        handleSearchKeyDown(e){\n        \n          if(e.key && e.key.toLowerCase() == 'enter'){\n            \n            this.handleSearch();\n            \n          } \n        }\n        \n        @autobind\n        handleTextareaKeydown(e){\n        \n          let nodeData = this.state.dataValue; \n          try {\n            nodeData = universe.dirtyJSON.parse(nodeData);\n            \n            this.setState({\n              canParse: true\n            });\n            \n          }catch(err){\n            this.setState({\n              canParse: false\n            });\n          }\n          \n        } \n        \n        @autobind\n        async handleSearch(){\n          console.log('searching');\n          \n          // stellar key should be pasted in \n          let stellarKey = this.state.stellarKey;\n          \n          // let routeText = this.state.routeText;\n          let routeFullPath = this.state.routeFullPath;\n          \n          this.setState({\n            isSearching: true,\n            failedSearch: false\n          });\n          \n          try {\n            // parse route \n            // - parse twice, second time probably using http, cuz id/idtest are not recognized protocols yet \n            let parser;\n            if(typeof WINDOW != 'undefined'){\n              parser = WINDOW.document.createElement('a');\n              parser.href = routeFullPath; \n            } else {\n              const { URL } = universe.require('url');\n              parser = new URL(routeFullPath);\n            }\n            \n            let protocol = parser.protocol;\n            switch(protocol){\n              case 'id:':\n              case 'idtest:':\n              case 'second:':\n                parser.protocol = 'http:';\n                break;\n              \n              default:\n                WINDOW.alert('Invalid protocol. please use id:// or idtest:// or second://');\n                return false;\n            }\n            \n            let baseIdentity = parser.host;\n            let subname = parser.username || '';\n            let password = parser.password.length ? parser.password : null;\n            let routePath = parser.pathname ? parser.pathname.slice(1) : '';\n            \n            console.log('Parsed route:', {baseIdentity, subname, password, routePath});\n          \n            switch(protocol){\n              case 'id:':\n                universe.StellarSdk.Network.usePublicNetwork();\n                break;\n              case 'idtest:':\n                universe.StellarSdk.Network.useTestNetwork();\n                break;\n              case 'second:':\n                universe.StellarSdk.Network.useTestNetwork();\n                break;\n              default:\n                console.error('Invalid protocol');\n                return;\n            }\n            \n            let stellarServer = new universe.StellarSdk.Server(horizonPossible[protocol]);\n            \n            console.log('stellarServer', stellarServer);\n            \n            let usernameSeed = universe.crypto.createHash('sha256').update(baseIdentity).digest(); //returns a buffer\n            console.log('usernameSeed', usernameSeed);\n            \n            var pairForIdentity = universe.StellarSdk.Keypair.fromRawEd25519Seed(usernameSeed);\n            \n          \n            console.log('pairForIdentity', pairForIdentity);\n            \n            this.setState({\n              usernameClaimable: false,\n              usernameOwnedByMe: false\n            });\n            \n            let identityAccount;\n            try {\n              identityAccount = await stellarServer.loadAccount(pairForIdentity.publicKey())\n              console.log('identityAccount:', identityAccount);\n            }catch(err){\n              console.error('Failed getting identityAccount', err);\n              // WINDOW.alert('failed loading idenity');\n              \n              this.setState({\n                usernameClaimable: true\n              });\n            \n              throw 'Failed loading identity'\n            }\n            \n            // owned by me? \n            var pairSource = universe.StellarSdk.Keypair.fromSecret(this.state.stellarKey);\n            var pairSourcePublicKey = pairSource.publicKey();\n            for(let signer of identityAccount.signers){\n              if(signer.public_key == pairSourcePublicKey){\n                this.setState({\n                  usernameOwnedByMe: true\n                })\n              }\n            }\n            \n            let lookupPath = subname + '|' + routePath;\n            if(password){\n              lookupPath = password + '|' + subname + '|' + routePath;\n              // lookupPath = await encryptToString(subname + '|' + routePath, password+routePath)\n            }\n            \n            let lookupPathHash = universe.crypto.createHash('sha256').update(lookupPath).digest('hex'); \n             \n            \n            console.log('lookupPathHash', lookupPathHash);\n      \n            // get the ipfs value \n            let valueIpfsHash = await identityAccount.data({key: lookupPathHash})\n            .then(function(dataValue) {\n              let decoded = atob(dataValue.value);\n              return decoded;\n            })\n            .catch(function (err) {\n              console.error('ipfs error', err);\n              return null;\n            })\n            \n            console.log('Data Result:', valueIpfsHash);\n            if(!valueIpfsHash){\n              throw 'Missing data result'\n            }\n            \n            // Load IPFS data \n            let ipfsData = await getIpfsValue(valueIpfsHash);\n            \n            console.log('ipfsData:', ipfsData);\n            \n            let dec = ipfsData;\n            let actualValue = dec;\n            if(password){\n              console.log('had password'); \n              dec = await decryptToString(ipfsData, password+routePath);\n              console.log('decrypted1:', dec);\n              actualValue = await getIpfsValue(dec);\n              dec = await decryptToString(actualValue, password+routePath);\n              actualValue = dec;\n            }\n            \n            console.log('decrypted-same:', dec == actualValue ? true:false, dec, actualValue);\n            \n            \n            // expecting a Node type to be returned \n            let nodeData;\n            try {\n              nodeData = JSON.parse(actualValue);\n            }catch(err){\n              console.error('unable to parse nodedata');\n            }\n            \n            console.log('Final nodeData:', nodeData);\n            \n            this.setState({\n              dataValue: actualValue\n            });\n            \n          }catch(err){\n            // failed finding route data \n            console.error('Failed searching', err);\n            \n            this.setState({\n              failedSearch: true\n            })\n          \n          }\n          \n          this.setState({isSearching: false});\n          \n        }\n        \n        \n        @autobind\n        async addRouteData(e){\n          \n          // stellar key should be pasted in \n          let stellarKey = this.state.stellarKey;\n          \n          let nodeData = this.state.dataValue; // expecting a string, should be JSON.parse'able \n          \n          try {\n            JSON.parse(nodeData);\n          }catch(err){\n            WINDOW.alert('Invalid JSON specified');\n            return false;\n          }\n          \n          // let routeText = this.state.routeText;\n          let routeFullPath = this.state.routeFullPath;\n          \n          this.setState({\n            isSaving: true,\n            failedSaving: false\n          });\n          \n          try {\n              \n            // parse route \n            // - parse twice, second time probably using http, cuz id/idtest are not recognized protocols yet \n            let parser;\n            if(typeof WINDOW != 'undefined'){\n              parser = WINDOW.document.createElement('a');\n              parser.href = routeFullPath; \n            } else {\n              const { URL } = universe.require('url');\n              parser = new URL(routeFullPath);\n            }\n            \n            let protocol = parser.protocol;\n            switch(protocol){\n              case 'id:':\n              case 'idtest:':\n              case 'second:':\n                parser.protocol = 'http:';\n                break;\n              \n              default:\n                WINDOW.alert('Invalid protocol. please use id:// or idtest:// or second://');\n                throw 'Invalid protocol'\n            }\n            \n            let baseIdentity = parser.host;\n            let subname = parser.username || '';\n            let password = parser.password.length ? parser.password : null;\n            let routePath = parser.pathname ? parser.pathname.slice(1) : '';\n            \n            console.log('Parsed route:', {baseIdentity, subname, password, routePath});\n            \n            console.log('nodeData:', nodeData);\n            \n            // encrypt data using password\n            if(password){\n              nodeData = await encryptToString(nodeData, password+routePath);\n            }\n            \n            console.log('encrypted NodeData:', nodeData);\n            \n            // create IPFS hashes of nodeData \n            let ipfsHashOfData = await this.createIpfsHashOnSecond(nodeData); // TODO \n            \n            console.log('ipfsHashOfData:', ipfsHashOfData);\n            \n            let encryptedDataToSave,\n              ipfsHashOfEncryptedData;\n            if(password){\n              // encrypt the ipfs hash using password+path \n              console.log('Using password for encryption');\n              encryptedDataToSave = await encryptToString(ipfsHashOfData, password+routePath); // TODO\n              ipfsHashOfEncryptedData = await this.createIpfsHashOnSecond(encryptedDataToSave); \n              console.log('ipfsHashOfEncryptedData:', ipfsHashOfEncryptedData);\n            }\n            \n            \n            // Add files and pin data to IPFS \n            // TODO \n            \n            \n            // Write to Stellar \n            console.log('Writing to stellar', protocol);\n          \n            switch(protocol){\n              case 'id:':\n                universe.StellarSdk.Network.usePublicNetwork();\n                break;\n              case 'idtest:':\n                universe.StellarSdk.Network.useTestNetwork();\n                break;\n              case 'second:':\n                universe.StellarSdk.Network.useTestNetwork();\n                break;\n              default:\n                console.error('Invalid protocol');\n                throw 'Invalid protocol'\n            }\n            \n            let stellarServer = new universe.StellarSdk.Server(horizonPossible[protocol]);\n            \n            console.log('stellarServer', stellarServer);\n            \n            let usernameSeed = universe.crypto.createHash('sha256').update(baseIdentity).digest(); //returns a buffer\n            console.log('usernameSeed', usernameSeed);\n            \n            var pairForIdentity = universe.StellarSdk.Keypair.fromRawEd25519Seed(usernameSeed);\n            \n            \n            // multi-sig address for updating \n            var pairForWrite = universe.StellarSdk.Keypair.fromSecret(stellarKey);\n            \n            \n            console.log('pairForIdentity', pairForIdentity);\n            \n            let identityAccount;\n            try {\n              identityAccount = await stellarServer.loadAccount(pairForIdentity.publicKey())\n              console.log('identityAccount:', identityAccount);\n            }catch(err){\n              console.error('Failed getting identityAccount', err);\n              WINDOW.alert('failed loading idenity');\n              throw 'Failed loading identity'\n            }\n            \n            // write the new data value \n            console.log('writing ipfs values to ipfs');\n             \n            let lookupPath = subname + '|' + routePath;\n            if(password){\n              lookupPath = password + '|' + subname + '|' + routePath;\n              // lookupPath = await encryptToString(subname + '|' + routePath, password+routePath)\n            }\n            \n            let lookupPathHash = universe.crypto.createHash('sha256').update(lookupPath).digest('hex'); \n            \n            let value = ipfsHashOfEncryptedData || ipfsHashOfData;\n            let name = lookupPathHash;\n            \n            console.log('name, value:', name, value);\n            \n            // Start building the transaction for manageData update\n            let transaction = new universe.StellarSdk.TransactionBuilder(identityAccount)\n            \n            .addOperation(universe.StellarSdk.Operation.manageData({\n              name, // just use /path ? \n              value // encrypted, if exists \n            }))\n            // .addMemo(StellarSdk.Memo.hash(b32))\n            .build();\n  \n            // Sign the transaction to prove you are actually the person sending it.\n            transaction.sign(pairForIdentity); // targetKeys\n            transaction.sign(pairForWrite); // sourceKeys\n  \n            // send to stellar network\n            let stellarResult = await stellarServer.submitTransaction(transaction)\n            .then(function(result) {\n              console.log('Stellar manageData Success! Results:'); //, result);\n              return result;\n            })\n            .catch(function(error) {\n              console.error('Stellar Something went wrong (failed updating data)!', error);\n              // If the result is unknown (no response body, timeout etc.) we simply resubmit\n              // already built transaction:\n              // server.submitTransaction(transaction);\n              return null;\n            });\n  \n            // console.log('stellarResult', stellarResult);\n  \n            if(!stellarResult){\n              console.error('Failed stellar manageData');\n              throw 'Failed stellar manageData'\n            }\n  \n            console.log('stellarResult succeeded! (manageData)');\n            \n            console.log('stellarResult', stellarResult);\n            \n          }catch(err){\n            // failed finding route data \n            console.error('Failed searching', err);\n            \n            this.setState({\n              failedAdd: true\n            })\n          \n          }\n          \n          this.setState({isSaving: false});\n          \n        }\n        \n        @autobind\n        handleViewAccount(){\n          \n          let stellarKey = this.state.stellarKey;\n          \n          let routePath = this.state.routePath;\n          \n          try {\n              \n            // parse route \n            // - parse twice, second time probably using http, cuz id/idtest are not recognized protocols yet \n            let parser;\n            if(typeof WINDOW != 'undefined'){\n              parser = WINDOW.document.createElement('a');\n              parser.href = routePath; \n            } else {\n              const { URL } = universe.require('url');\n              parser = new URL(routePath);\n            }\n            \n            let protocol = parser.protocol;\n            switch(protocol){\n              case 'id:':\n              case 'idtest:':\n              case 'second:':\n                parser.protocol = 'http:';\n                break;\n              \n              default:\n                WINDOW.alert('Invalid protocol. please use id:// or idtest:// or second://');\n                throw 'Invalid protocol'\n            }\n            \n            let baseIdentity = parser.host;\n            \n            let pkTargetSeed = universe.jsSHA256.array(baseIdentity);\n            var pairTarget = universe.StellarSdk.Keypair.fromRawEd25519Seed(pkTargetSeed);\n            \n            let href = `https://horizon-testnet.stellar.org/accounts/${pairTarget.publicKey()}`;\n            \n            WINDOW.open(href, '_blank');\n            \n            console.log('href:', href);\n          \n          }catch(err){\n            console.error('Failed finding identity link:', err);\n            \n          }\n        }\n        \n        @autobind\n        createIpfsHashOnSecond(fileValue){\n          // shared_node\n          // \n          return new Promise(async (resolve,reject)=>{\n              \n            try {\n              \n              this.setState({\n                isCreating: true\n              })\n              \n              let response = await universe.loadAndRunCapability('TalkToSecond',{\n                type: 'default_loadandruncapability_options:Qmf239j',\n                data: {\n                  skipSameAppPlatform: true\n                }\n              },{\n                type: 'standard_capability_action:0.0.1:local:298j291bs',\n                data: {\n                  action: 'send',\n                  options: {\n                    ExternalIdentityNode: this.props.state.OwnerSecondExternalIdentityNode,\n                    RequestNode: {\n                      type: 'run_action_sequence:0.0.1:local:293fh8239hsdf23f',\n                      data: {\n                        actions: [\n                          \n                          {\n                            matchActionType: 'identify_via_token:0.0.1:local:237823783g2123',\n                            dataForAction: {\n                              type: 'string:...',\n                              data: this.props.state.OwnerSecondExternalIdentityNode.data.token\n                            }\n                          },\n                      \n                          { \n                            matchActionType: 'ipfs_file_add:Qmfmk230fjs',\n                            dataForAction: {\n                              type: 'standard_query_request:0.0.1:local:65723f2khfds',\n                              data: {\n                                type: 'file_with_data_and_options:Qmdf23ifsmkmm',\n                                data: {\n                                  options: {\n                                    pin: true\n                                  },\n                                  fileValue\n                                }\n                              }\n                            }\n                          },\n                          \n                        ]\n                        \n                      }\n                    }\n                  }\n                }\n              });\n              \n              console.log('Response:', response);\n              \n              let hash = response.data.actionResponses[1].data.hash;\n              \n              // Pin! \n              resolve(hash);\n              // {\n              //   type: 'ipfs_hash:Qmdflj',\n              //   data: hash\n              // });\n              \n            } catch(err){\n              console.error('Failed TalkToSecond request', err);\n              reject();\n            }\n          \n            this.setState({\n              isCreating: false\n            })\n            \n            \n            return;\n            \n          });\n          \n        }\n        \n        @autobind\n        handlePrettify(){\n          \n          let nodeData = this.state.dataValue; \n          try {\n            nodeData = universe.dirtyJSON.parse(nodeData);\n            \n            this.setState({\n              dataValue: JSON.stringify(nodeData, null, 2)\n            })\n            \n          }catch(err){\n          }\n          \n          \n        }\n        \n        render(){\n          \n          return (\n        \n            <div className=\"section\">\n              <div className=\"container\">\n                <div className=\"columns\">\n                \n                  <div className=\"column is-6 is-offset-3\">\n                    \n                    <div>\n                    \n                      <h3 className=\"subtitle is-6\">\n                        <strong>Username: </strong>\n                        <span>{this.props.state.UsernamePassphraseNode.data.username}</span>\n                      </h3>\n                      <h3 className=\"subtitle is-6\">\n                        <strong>Passphrase: </strong>\n                        <br />\n                        <span>{this.props.state.UsernamePassphraseNode.data.passphrase}</span>\n                      </h3>\n                    \n                    </div>\n                    \n                    <hr />\n                    \n                    \n                    <div>\n                      \n                      <div className=\"field has-addons\">\n                        <div className=\"control\">\n                          <input className=\"input\" value={this.state.routeHost} onChange={e=>this.setState({routeHost:e.target.value}, this.updateRouteFullPath)} placeholder=\"\" disabled={true} />\n                        </div>\n                        <div className=\"control is-expanded\">\n                          <input className=\"input\" value={this.state.routeText} onChange={e=>this.setState({routeText:e.target.value}, this.updateRouteFullPath)} placeholder=\"\" onKeyDown={this.handleSearchKeyDown} />\n                        </div>\n                        <div className=\"control\">\n                          <button className={\"button is-info \" + (this.state.isSearching ? 'is-loading':'')} onClick={this.handleSearch}>Load Data For Route</button>\n                        </div>\n                        <div className=\"control\">\n                          <button className={\"button is-success \" + (this.state.isSaving ? 'is-loading':'')} \n                          onClick={this.addRouteData}\n                          disabled={!this.state.usernameOwnedByMe}\n                          >Save Data</button>\n                        </div>\n                        \n                        {/* can be claimed? \n                        <div className=\"control\">\n                          <button className={\"button is-default \" + (this.state.isClaiming ? 'is-loading':'')} \n                          onClick={this.handleClaimUsername}\n                          disabled={!this.state.usernameClaimable}>Claim Username</button>\n                        </div>\n                        <div className=\"control\">\n                          <button className={\"button is-default \" + (this.state.isFunding ? 'is-loading':'')} onClick={this.handleFundAccount}>Add Funds</button>\n                        </div>\n                        \n                        \n                        <div className=\"control\">\n                          <button className={\"button is-default \"} onClick={this.handleViewAccount}>View Account</button>\n                        </div>\n                        \n                        <div className=\"control\">\n                          <button className={\"button is-default \"}>Change Private Key (SBKO...)</button>\n                        </div>\n                        */}\n                        \n                      </div>\n                      \n                      \n                      <div>\n                        {\n                          !this.state.failedAdd ? '':\n                          <span className='has-text-danger'>\n                            Failed adding\n                          </span>\n                        }\n                        {\n                          !this.state.failedSearch ? '':\n                          <span className='has-text-danger'>\n                            Failed loading route data\n                          </span>\n                        }\n                        {\n                          !this.state.failedClaim ? '':\n                          <span className='has-text-danger'>\n                            Failed claiming identity\n                          </span>\n                        }\n                        {\n                          !this.state.failedFunding ? '':\n                          <span className='has-text-danger'>\n                            Failed funding\n                          </span>\n                        }\n                        &nbsp;\n                      </div>\n                      \n                    </div>\n                    \n                    <br />\n                    \n                    <div>\n                      \n                      <textarea \n                        className='textarea' \n                        onChange={e=>this.setState({dataValue: e.target.value})} \n                        onKeyDown={this.handleTextareaKeydown}\n                        value={this.state.dataValue} \n                        rows=\"10\" \n                      />\n                      \n                      <br />\n                    \n                      <div className=\"control\">\n                        <button \n                          className={\"button is-default \"} \n                          onClick={this.handlePrettify}\n                          disabled={!this.state.canParse}\n                        >Prettify JSON</button>\n                      </div>\n                    </div>\n                    \n                    <br />\n                    \n                    <div className=\"\">\n                      <span>\n                        Anyone can view the route's data by visiting: \n                        &nbsp;\n                        <a href={`https://viewsecondroute.com/${this.state.routeFullPath}`}>\n                          https://viewsecondroute.com/{this.state.routeFullPath}\n                        </a>\n                      </span>\n                    </div>\n                    \n                  </div>\n                  \n                </div>\n                \n              </div>\n              \n            </div>\n            \n            \n          )\n        }\n      }\n      \n      if(universe.sharedComponents && universe.sharedComponents.withEditableNodeInfo){\n        mycomponent = universe.sharedComponents.withEditableNodeInfo(mycomponent, {\n          localNode: SELF,\n          localNodeIsRemote: true\n        });\n      }\n       \n      mycomponent = universe.ReactGlobalState(mycomponent);\n      mycomponent = universe.ReactHelpers(mycomponent);\n      \n      const styles = {\n        deleteIcon: {\n          position: 'absolute',\n          top: '0px',\n          right: '-24px',\n          cursor: 'pointer'\n        }\n      }\n      \n      resolve({\n        type: 'react_component:0.0.1:local:98912hd89',\n        data: mycomponent\n      });\n      \n    }catch(err){\n      reject({\n        ERROR: true, \n        err: err.toString()\n      });\n    }\n    \n  })\n\n  \n})()",
    "internalId": "MainHomeComponent"
  }
}